Guía Rápida: Servidor de Usuarios Seguro (Node.js + PostgreSQL)

¡Hola! Esta guía te ayudará a entender los componentes clave de seguridad en tu servidor de usuarios, explicando por qué el código es "poco" pero muy potente.

La seguridad no reside en la cantidad de líneas de código que escribes para ella, sino en la calidad y robustez de los algoritmos y librerías que utilizas. En tu caso, `bcrypt` y `jsonwebtoken` son librerías de código abierto, auditadas y probadas por miles de desarrolladores, que implementan los estándares de seguridad más altos.

--------------------------------------------------------------------------------

**Componentes Clave de Seguridad:**

1.  **.env (Variables de Entorno):**
    *   **¿Qué es?** Un archivo para guardar información sensible (claves secretas, contraseñas de base de datos) fuera de tu código fuente.
    *   **¿Por qué es seguro?** Evita que tus secretos se suban a repositorios públicos (como GitHub) o se expongan si tu código fuente es comprometido. Solo el servidor que ejecuta la aplicación tiene acceso a ellos.
    *   **Tu rol:** Asegurarte de que el archivo `.env` nunca se suba a Git (añádelo a `.gitignore`) y que los valores sean realmente secretos y complejos (especialmente `JWT_SECRET`).

2.  **Hashing de Contraseñas (con `bcrypt`):**
    *   **¿Qué es?** Un proceso unidireccional que convierte una contraseña en una cadena de caracteres ilegible (el "hash"). No se puede revertir.
    *   **¿Qué es el "Salt"?** Una cadena aleatoria única que se añade a cada contraseña ANTES de hashearla. `bcrypt` lo gestiona automáticamente.
    *   **¿Por qué es seguro?**
        *   **Protección contra fugas de BD:** Si tu base de datos es robada, los atacantes solo tendrán hashes, no las contraseñas reales. Es computacionalmente inviable revertir un hash de `bcrypt`.
        *   **Protección contra ataques de "tablas arcoíris":** El "salt" asegura que dos usuarios con la misma contraseña tengan hashes diferentes, frustrando ataques precalculados.
    *   **Tu rol en el código (`index.js`):**
        *   **Registro:** `const hashedPassword = await bcrypt.hash(password, salt);` (aquí `bcrypt` hace todo el trabajo pesado de hashear y saltear).
        *   **Login:** `const isMatch = await bcrypt.compare(password, user.password);` (aquí `bcrypt` compara la contraseña ingresada con el hash guardado, manejando el salt internamente).

3.  **JWT (JSON Web Tokens - para Sesiones):**
    *   **¿Qué es?** Un token seguro que se usa para mantener la sesión de un usuario autenticado sin tener que enviar sus credenciales en cada petición.
    *   **¿Por qué es seguro?**
        *   **Firma Digital:** El token está firmado con una `JWT_SECRET` que solo tu servidor conoce. Cualquier intento de modificar el token (ej: cambiar el ID de usuario) invalidará la firma, y tu servidor lo rechazará.
        *   **Sin estado en el servidor:** El servidor no necesita guardar información de la sesión, lo que lo hace más escalable.
    *   **Tu rol en el código (`index.js`):**
        *   **Login:** `const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' });` (aquí `jsonwebtoken` crea el token, lo firma y le añade una expiración).
        *   **Rutas Protegidas:** `jwt.verify(token, process.env.JWT_SECRET, (err, payload) => { ... });` (aquí `jsonwebtoken` verifica la firma del token y su expiración).

--------------------------------------------------------------------------------

**Guía Paso a Paso (Resumida):**

1.  **Configurar Base de Datos (PostgreSQL):**
    *   Asegúrate de tener PostgreSQL instalado y funcionando.
    *   Ejecuta el script `users.sql` para crear la tabla `users`.

2.  **Inicializar Proyecto y Dependencias:**
    *   Abre tu terminal en la carpeta `AuthBack`.
    *   `npm init -y`
    *   `npm install express pg bcryptjs jsonwebtoken dotenv cors nodemon`

3.  **Configurar Variables de Entorno (`.env`):**
    *   Crea un archivo `.env` en la raíz de tu proyecto (`AuthBack/`).
    *   Añade el siguiente contenido (¡reemplaza los valores con los tuyos!):
        ```
        # PostgreSQL Database connection
        DB_USER=postgres
        DB_HOST=localhost
        DB_DATABASE=your_database_name
        DB_PASSWORD=your_password
        DB_PORT=5432

        # JWT Secret Key (¡MUY LARGA Y ALEATORIA!)
        JWT_SECRET=tuclavesecretamuylargaaleatoriaysegura
        ```
    *   **¡IMPORTANTE!** Añade `.env` a tu archivo `.gitignore` para que no se suba a Git.

4.  **Código del Servidor (`index.js` - Estructura Clave):**
    *   Este es el archivo que ya tienes. Sus partes clave para la seguridad son:
        ```javascript
        // Importaciones (dotenv para .env, bcrypt para hash, jwt para tokens)
        require('dotenv').config();
        const bcrypt = require('bcryptjs');
        const jwt = require('jsonwebtoken');

        // Configuración de la BD (usa las variables de .env)
        const pool = new Pool({
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            // ... otras configuraciones
        });

        // Ruta de Registro
        app.post('/register', async (req, res) => {
            // ... validación de email/password
            const salt = await bcrypt.genSalt(10); // Genera el salt
            const hashedPassword = await bcrypt.hash(password, salt); // Hashea la contraseña
            // ... guarda hashedPassword en la BD
        });

        // Ruta de Login
        app.post('/login', async (req, res) => {
            // ... busca usuario por email
            const isMatch = await bcrypt.compare(password, user.password); // Compara contraseña con hash
            if (!isMatch) { /* ... error ... */ }

            const payload = { user: { id: user.id } };
            const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' }); // Crea y firma el JWT
            res.json({ token });
        });

        // Middleware de Autenticación (para rutas protegidas)
        const authenticateToken = (req, res, next) => {
            const token = req.headers['authorization'] && req.headers['authorization'].split(' ')[1];
            if (!token) return res.sendStatus(401);

            jwt.verify(token, process.env.JWT_SECRET, (err, payload) => {
                if (err) return res.sendStatus(403); // Token inválido o expirado
                req.user = payload.user; // Guarda la info del usuario del token en la petición
                next();
            });
        };

        // Ruta Protegida de Ejemplo
        app.get('/profile', authenticateToken, async (req, res) => {
            // ... aquí sabes que el usuario está autenticado y su ID está en req.user.id
        });

        // Iniciar el servidor
        app.listen(PORT, () => { /* ... */ });
        ```

5.  **Iniciar el Servidor:**
    *   `npm run dev` (usando `nodemon` para reinicio automático).

6.  **Probar la API:**
    *   Usa Postman, Insomnia o `curl` para probar:
        *   `POST /register` (con email y password)
        *   `POST /login` (con email y password, obtendrás un token)
        *   `GET /profile` (con el token en la cabecera `Authorization: Bearer <tu_token>`).

--------------------------------------------------------------------------------

**¿Por qué es seguro con "poco" código?**

Porque las librerías `bcrypt` y `jsonwebtoken` encapsulan algoritmos criptográficos complejos y probados. No necesitas entender cada bit y byte de cómo funciona el hasheo o la firma de tokens; solo necesitas saber cómo usarlos correctamente (que es lo que ya haces).

La seguridad no es magia, es matemáticas y algoritmos bien implementados. Y eso es lo que estas librerías te proporcionan.

¡Espero que esta guía te dé más confianza en tu implementación!

Esto es una prueba del primer push en Linux, vamos a probar que tal sale.